// background.js - Service Worker

// Handle keyboard shortcuts
chrome.commands.onCommand.addListener((command, tab) => {
  if (command === 'auto-correct') {
    chrome.tabs.sendMessage(tab.id, { action: 'autoCorrect' });
  } else if (command === 'generate-code') {
     chrome.tabs.sendMessage(tab.id, { action: 'generateCode' });
  }
});

// Listen for messages from content script or popup
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === 'autoCorrect') {
    handleAutoCorrect(request.code, sender.tab.id).then(sendResponse);
    return true; // Indicates we will send a response asynchronously
  } else if (request.action === 'generate') {
    handleGenerate(request.prompt, sender.tab.id).then(sendResponse);
    return true; // Indicates we will send a response asynchronously
  }
  return false;
});

async function handleAutoCorrect(code, tabId) {
  try {
    const keys = await chrome.storage.local.get(['geminiKey', 'huggingfaceKey']);
    const correctedCode = await autoCorrectCodeWithFallback(code, keys);
    
    // The content script will do the replacing after it gets the response
    return { code: correctedCode };
  } catch (error) {
    console.error('Auto-correct failed:', error);
    return { error: error.message };
  }
}

async function handleGenerate(prompt, tabId) {
  try {
    const keys = await chrome.storage.local.get(['geminiKey', 'huggingfaceKey']);
    const code = await generateCodeWithFallback(prompt, keys);
    
    // The content script will do the insertion after it gets the response
    return { code: code };
  } catch (error) {
    console.error('Generate failed:', error);
    return { error: error.message };
  }
}

async function autoCorrectCodeWithFallback(code, keys) {
  const prompt = `Fix any syntax errors, bugs, or issues in this code. Return ONLY the corrected code without explanations or markdown fences:\n\n${code}`;
  
  // Try Gemini
  try {
    return await callGemini(prompt, 'gemini-1.5-flash', keys.geminiKey);
  } catch (err) {
    console.warn('Gemini for auto-correct failed:', err);
  }
  
  // Try HuggingFace
  try {
    return await callHuggingFace(prompt, keys.huggingfaceKey);
  } catch (err) {
    console.warn('HuggingFace for auto-correct failed:', err);
  }
  
  throw new Error('All AI models failed');
}

async function generateCodeWithFallback(prompt, keys) {
  // Try Gemini Flash
  try {
    return await callGemini(prompt, 'gemini-1.5-flash', keys.geminiKey);
  } catch (err) {
    console.warn('Gemini Flash failed:', err);
  }
  
  // Try Gemini Pro
  try {
    return await callGemini(prompt, 'gemini-1.5-pro', keys.geminiKey);
  } catch (err) {
    console.warn('Gemini Pro failed:', err);
  }
  
  // Try HuggingFace
  try {
    return await callHuggingFace(prompt, keys.huggingfaceKey);
  } catch (err) {
    console.warn('HuggingFace failed:', err);
  }
  
  // Final fallback: Web search
  try {
    return await searchWebForCode(prompt);
  } catch (err) {
    console.warn('Web Search failed:', err);
  }
  
  throw new Error('All code generation methods failed.');
}

async function callGemini(prompt, model, apiKey) {
  if (!apiKey) throw new Error('Gemini API key is not set.');
  const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;
  
  const response = await fetch(endpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-goog-api-key': apiKey
    },
    body: JSON.stringify({
      contents: [{
        parts: [{
          text: `Generate clean code for: ${prompt}. Return ONLY code, no explanations or markdown.`
        }]
      }],
      generationConfig: {
        temperature: 0.7,
        maxOutputTokens: 2048
      }
    })
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => null);
    const message = errorData?.error?.message || `Gemini API error: ${response.status}`;
    throw new Error(message);
  }
  
  const data = await response.json();
  if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
    let code = data.candidates[0].content.parts[0].text;
    return code.replace(/^```[\w-]*\n/, "").replace(/\n```$/, "").trim();
  }
  
  throw new Error('No code generated by Gemini');
}

async function callHuggingFace(prompt, apiKey) {
  if (!apiKey) throw new Error('HuggingFace API key is not set.');
  const response = await fetch('https://api-inference.huggingface.co/models/codellama/CodeLlama-34b-Instruct-hf', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    },
    body: JSON.stringify({
      inputs: `Generate code for: ${prompt}. Return only code.`,
      parameters: {
        max_new_tokens: 2048,
        temperature: 0.7,
        return_full_text: false
      }
    })
  });
  
  if (!response.ok) {
    throw new Error(`HuggingFace API error: ${response.status}`);
  }
  
  const data = await response.json();
  if (Array.isArray(data) && data[0]?.generated_text) {
    return data[0].generated_text.trim();
  }
  
  throw new Error('No code generated by HuggingFace');
}

async function searchWebForCode(prompt) {
  const query = encodeURIComponent(`${prompt} code example site:stackoverflow.com OR site:github.com`);
  return `// Web search fallback activated.\n// Try searching for your query on popular developer sites:\n\n// Search on Stack Overflow:\n// https://stackoverflow.com/search?q=${query}\n\n// Search on GitHub:\n// https://github.com/search?q=${query}&type=code\n`;
}


// Context menu for right-click
chrome.runtime.onInstalled.addListener(() => {
  chrome.contextMenus.create({
    id: 'ai-auto-correct',
    title: 'Auto-correct with AI',
    contexts: ['selection']
  });
  
  chrome.contextMenus.create({
    id: 'ai-generate',
    title: 'Generate code from selection',
    contexts: ['selection']
  });
});

chrome.contextMenus.onClicked.addListener((info, tab) => {
  if (info.menuItemId === 'ai-auto-correct') {
    handleAutoCorrect(info.selectionText, tab.id);
  } else if (info.menuItemId === 'ai-generate') {
    handleGenerate(info.selectionText, tab.id);
  }
});
